// Copyright 2012 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.google.enterprise.connector.notes;

import com.google.common.annotations.VisibleForTesting;
import com.google.enterprise.connector.notes.client.NotesACL;
import com.google.enterprise.connector.notes.client.NotesACLEntry;
import com.google.enterprise.connector.notes.client.NotesDatabase;
import com.google.enterprise.connector.notes.client.NotesDateTime;
import com.google.enterprise.connector.notes.client.NotesDocument;
import com.google.enterprise.connector.notes.client.NotesSession;
import com.google.enterprise.connector.notes.client.NotesView;
import com.google.enterprise.connector.notes.client.NotesViewEntry;
import com.google.enterprise.connector.notes.client.NotesViewNavigator;
import com.google.enterprise.connector.spi.LocalDatabase;
import com.google.enterprise.connector.spi.RepositoryException;
import com.google.enterprise.connector.util.database.DatabaseConnectionPool;
import com.google.enterprise.connector.util.database.JdbcDatabase;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.Vector;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Creates a cache of user, group, and role data.
 *
 * Tables (note that the actual table names are generated and are
 * not exactly the names used here):
 *
 * users: userid (primary key),
 *        notesname (Notes username, expected to be in
 *                   the form "cn=.../ou=.../o=..."),
 *        gsaname (username used for GSA authentication;
 *                 generated by the connector)
 *
 * groups: groupid (primary key)
 *         groupname (Notes group name)
 *         pseudogroup (boolean used to flag the groups constructed
 *                      from the Notes usernames)
 *
 * roles: roleid (primary key)
 *        rolename (name of the role from database ACL)
 *
 * usergroups: userid (key from users table)
 *             groupid (key from groups table)
 *
 * userroles: userid (key from users table)
 *            roleid (key from roles table)
 *
 * grouproles: groupid (key from groups table)
 *             roleid (key from roles table)
 *
 * groupchildren: parentgroupid (key from groups table)
 *                childgroupid (key from groups table)
 *
 * The users table is used to map Notes usernames to the GSA
 * usernames. Not every Notes user in the configured directory
 * will be included here; a Notes selection formula is used to
 * determine which users are included. The GSA usernames are
 * generated here.
 *
 * The groups table is used to maintain a list of group names. In
 * addition to groups from the Notes directory, this table caches
 * pseudo-groups generated from the Notes usernames. For example,
 * a user with a name of "cn=Z/ou=X/o=Y" will trigger the
 * creation of pseudo-groups "ou=X/o=Y" and "o=Y".
 *
 * The roles table is used to cache a list of roles configured in
 * the databases being crawled. Each database's ACL will be
 * examined for existing roles. Role names will be prefixed with
 * the database replica id to allow the connector to distinguish
 * the same role name in different databases. Example: 12345/[role].
 *
 * The usergroups table represents user group memberships. For
 * each entry, the given user is a member of the given group.
 *
 * The userroles table represents user roles. For each entry, the
 * given user has been assigned the indicated role in a database ACL.
 *
 * The grouproles table represents group roles. For each entry, the
 * given group has been assigned the indicated role in a database ACL.
 *
 * The groupchildren table represents nested group
 * membership. For each entry, the group indicated by
 * childgroupid is a member of the group indicated by
 * parentgroupid.
 */
/*
 * TODO: move SQL into properties file
 * TODO: create utility methods for rest of connector
 * TODO: decide on where to handle locking; can we depend on the
 * database, or do we need synchronization here?
 * TODO: can we use TOLOWER in the SQL statements, or do we need
 * to do it here? Also, can we lower-case group and role names
 * the way we do user names? This is more interesting with a
 * database if the database is going to use case-sensitive
 * searches.
 */
public class NotesUserGroupManagerDatabase {
  private static final String CLASS_NAME =
      NotesUserGroupManagerDatabase.class.getName();
  private static final Logger LOGGER = Logger.getLogger(CLASS_NAME);

  private NotesConnectorSession connectorSession;
  private NotesSession notesSession;
  private NotesDatabase connectorDatabase;
  private NotesDatabase directoryDatabase;
  private NotesView peopleGroupsView;
  private DatabaseConnectionPool connectionPool;
  private boolean originalAutoCommit;
  private int originalTransactionIsolation;
  private Connection conn;
  @VisibleForTesting final String userTableName;
  @VisibleForTesting final String groupTableName;
  @VisibleForTesting final String roleTableName;
  @VisibleForTesting final String userGroupsTableName;
  @VisibleForTesting final String userRolesTableName;
  @VisibleForTesting final String groupRolesTableName;
  @VisibleForTesting final String groupChildrenTableName;

  NotesUserGroupManagerDatabase(NotesConnectorSession connectorSession)
      throws RepositoryException {
    this.connectorSession = connectorSession;
    JdbcDatabase jdbcDatabase =
        connectorSession.getConnector().getJdbcDatabase();
    String connectorName =
        connectorSession.getConnector().getGoogleConnectorName();
    userTableName = jdbcDatabase.makeTableName("users_", connectorName);
    groupTableName = jdbcDatabase.makeTableName("groups_", connectorName);
    roleTableName = jdbcDatabase.makeTableName("roles_", connectorName);
    userGroupsTableName =
        jdbcDatabase.makeTableName("usergroups_", connectorName);
    userRolesTableName =
        jdbcDatabase.makeTableName("userroles_", connectorName);
    groupRolesTableName =
        jdbcDatabase.makeTableName("grouproles_", connectorName);
    groupChildrenTableName =
        jdbcDatabase.makeTableName("groupchildren_", connectorName);
    LOGGER.logp(Level.FINEST, CLASS_NAME, "<init>",
        "Tables:"
        + "\nuser: " + userTableName
        + "\ngroup: " + groupTableName
        + "\nrole: " + roleTableName
        + "\nuserGroups: " + userGroupsTableName
        + "\nuserRoles: " + userRolesTableName
        + "\ngroupRoles: " + groupRolesTableName
        + "\ngroupChildren: " + groupChildrenTableName);
    initializeUserCache();
  }

  public void updateUsersGroups() {
    updateUsersGroups(false);
  }

  /**
   * Updates the cached lists of people and groups. When force is
   * true, the configure cache update interval is ignored and the
   * user and group cache is updated.
   *
   * @param force if true, force an update
   */
  public void updateUsersGroups(boolean force) {
    final String METHOD = "updateUsersGroups";
    LOGGER.entering(CLASS_NAME, METHOD);
    try {
      if (!setUpResources(force)) {
        return;
      }

      // Pass 1 - Update groups
      updateGroups();

      // Pass 2 - Update people
      updateUsers();

      // Pass 3 - Update roles
      updateRoles();

      // Pass 4 - Delete any users that no longer exist
      checkUserDeletions();

      // Pass 5 - Delete any groups that no longer exist
      checkGroupDeletions();

      setLastCacheUpdate();
    } catch (RepositoryException e) {
      LOGGER.logp(Level.SEVERE, CLASS_NAME, METHOD,
          "Failure updating user/group cache", e);
    } finally {
      releaseResources();
      LOGGER.exiting(CLASS_NAME, METHOD);
    }
  }

  @VisibleForTesting
  boolean setUpResources(boolean force) throws RepositoryException {
    notesSession = connectorSession.createNotesSession();
    connectorDatabase = notesSession.getDatabase(
        connectorSession.getServer(), connectorSession.getDatabase());
    // Check our update interval.
    if (!force && !shouldUpdate(connectorDatabase)) {
      return false;
    }
    directoryDatabase = notesSession.getDatabase(
        connectorSession.getServer(), connectorSession.getDirectory());
    peopleGroupsView = directoryDatabase.getView(
        NCCONST.DIRVIEW_PEOPLEGROUPFLAT);
    peopleGroupsView.refresh();
    try {
      connectionPool = connectorSession.getConnector().getJdbcDatabase()
          .getConnectionPool();
      conn = connectionPool.getConnection();
      originalTransactionIsolation = conn.getTransactionIsolation();
      originalAutoCommit = conn.getAutoCommit();
      conn.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
    } catch (SQLException e) {
      throw new RepositoryException(
          "Failure obtaining database connection for user cache", e);
    }
    return true;
  }

  void releaseResources() {
    final String METHOD = "releaseResources";
    Util.recycle(peopleGroupsView);
    peopleGroupsView = null;
    Util.recycle(directoryDatabase);
    directoryDatabase = null;
    Util.recycle(connectorDatabase);
    connectorDatabase = null;
    connectorSession.closeNotesSession(notesSession);
    notesSession = null;
    if (conn != null) {
      try {
        conn.setAutoCommit(originalAutoCommit);
        conn.setTransactionIsolation(originalTransactionIsolation);
      } catch (SQLException e) {
        LOGGER.logp(Level.WARNING, CLASS_NAME, METHOD,
            "Error releasing database connection", e);
      } finally {
        connectionPool.releaseConnection(conn);
        conn = null;
      }
    }
    connectionPool = null;
  }

  @VisibleForTesting
  Connection getConnection() {
    return conn;
  }

  // Update groups

  /**
   * Loop over the groups in NCCONST.DIRVIEW_PEOPLEGROUPFLAT. For
   * each group, create a group record and compute nested group
   * membership (all groups which are contained within this group
   * via 0 or more intermediate groups).
   */
  @VisibleForTesting
  void updateGroups() throws RepositoryException {
    final String METHOD = "updateGroups";
    LOGGER.entering(CLASS_NAME, METHOD);

    NotesDocument groupDoc = null;
    String groupName = null;
    try {
      for (groupDoc = peopleGroupsView.getFirstDocument();
           groupDoc != null;
           groupDoc = getNextDocument(peopleGroupsView, groupDoc)) {
        try {
          groupName = groupDoc.getItemValueString(NCCONST.GITM_LISTNAME);
          // Only process groups
          if (!isAccessControlGroup(groupDoc)) {
            LOGGER.logp(Level.FINEST, CLASS_NAME, METHOD,
                "Not a group/access control group: '" + groupName + "'");
            continue;
          }
          updateGroup(groupDoc, groupName);
        } catch (SQLException e) {
          LOGGER.logp(Level.WARNING, CLASS_NAME, METHOD,
              "Failed to update group cache" +
              (groupName != null ? " for " + groupName : ""), e);
        }
      }
    } finally {
      Util.recycle(groupDoc);
    }
  }

  private void updateGroup(NotesDocument groupDoc, String groupName)
      throws SQLException, RepositoryException {
    final String METHOD = "updateGroup";
    LOGGER.entering(CLASS_NAME, METHOD);

    if (LOGGER.isLoggable(Level.FINEST)) {
      LOGGER.logp(Level.FINEST, CLASS_NAME, METHOD,
          "Processing group " + groupName);
    }
    // Find the nested groups.
    LinkedHashSet<String> processedGroups = new LinkedHashSet<String>();
    LinkedHashSet<String> nestedGroups = new LinkedHashSet<String>();
    getNestedGroups(groupDoc, groupName, processedGroups, nestedGroups);
    if (LOGGER.isLoggable(Level.FINEST)) {
      LOGGER.logp(Level.FINEST, CLASS_NAME, METHOD,
          "Nested groups for " + groupName + " are: " + nestedGroups);
    }
    // Update the group record and the parent/descendent group records.
    try {
      conn.setAutoCommit(false);
      long groupid = verifyGroupExists(groupName, true);

      // Delete previous parent/child records for this group.
      PreparedStatement pstmt = conn.prepareStatement(
          "delete from " + groupChildrenTableName
          + " where parentgroupid = ?");
      pstmt.setLong(1, groupid);
      pstmt.executeUpdate();

      // Add new parent/child records for this group.
      if (nestedGroups.size() > 0) {
        pstmt = conn.prepareStatement("insert into "
            + groupChildrenTableName + " (parentgroupid, childgroupid)"
            + " values (?, ?)");
        pstmt.setLong(1, groupid);
        for (String childGroupName : nestedGroups) {
          pstmt.setLong(2, verifyGroupExists(childGroupName, true));
          pstmt.executeUpdate();
        }
      }
      conn.commit();
    } catch (SQLException e) {
      LOGGER.logp(Level.WARNING, CLASS_NAME, METHOD,
          "Caught exception", e);
      conn.rollback();
    } finally {
      conn.setAutoCommit(true);
    }
  }

  @SuppressWarnings("unchecked")
  private void getNestedGroups(NotesDocument groupDoc, String groupName,
      Set<String> processedGroups, Set<String> nestedGroups)
      throws RepositoryException {
    final String METHOD = "getNestedGroups";
    LOGGER.entering(CLASS_NAME, METHOD);

    // Check for already processed groups to avoid cycles.
    if (!processedGroups.add(groupName)) {
      return;
    }
    Vector<String> groupMembers = groupDoc.getItemValue(NCCONST.GITM_MEMBERS);
    for (String member : groupMembers) {
      NotesDocument memberDoc = peopleGroupsView.getDocumentByKey(member);
      if (memberDoc == null) {
        continue;
      }
      try {
        if (!isAccessControlGroup(memberDoc)) {
          continue;
        }
        nestedGroups.add(member);
        getNestedGroups(memberDoc, member, processedGroups, nestedGroups);
      } finally {
        Util.recycle(memberDoc);
      }
    }
    LOGGER.exiting(CLASS_NAME, METHOD);
  }

  private long verifyGroupExists(String groupName,
    boolean createIfNotExists) throws SQLException, RepositoryException {
    final String METHOD = "verifyGroupExists";
    LOGGER.entering(CLASS_NAME, METHOD);

    PreparedStatement pstmt = conn.prepareStatement(
        "select * from " + groupTableName + " where groupname = ?",
        ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
    ResultSet generatedKeys = null;
    try {
      pstmt.setString(1, groupName);
      ResultSet rs = pstmt.executeQuery();
      if (rs.next()) {
        return rs.getLong("groupid");
      }
      if (!createIfNotExists) {
        return -1L;
      }
      rs.close();
      pstmt.close();
      pstmt = conn.prepareStatement("insert into " + groupTableName
          + "(groupname, pseudogroup) values (?, false)",
          Statement.RETURN_GENERATED_KEYS);
      pstmt.setString(1, groupName);
      int rows = pstmt.executeUpdate();
      if (rows == 0) {
        throw new RepositoryException(
            "Failed to create group record for " + groupName);
      }
      generatedKeys = pstmt.getGeneratedKeys();
      if (generatedKeys.next()) {
        return generatedKeys.getLong(1);
      } else {
        throw new RepositoryException(
            "Failed to retrieve key for " + groupName);
      }
    } finally {
      Util.close(generatedKeys);
      Util.close(pstmt);
      LOGGER.exiting(CLASS_NAME, METHOD);
    }
  }

  // Update users

  /**
   * Loop over the users in NCCONST.DIRVIEW_PEOPLEGROUPFLAT. For
   * each user, retrieve their Notes user name, construct their
   * GSA user name, and verify that they should be included using
   * the configured selection formula. Construct a user
   * record. Compute group membership and create user/group
   * records.
   */
  @VisibleForTesting
  void updateUsers() throws RepositoryException {
    final String METHOD = "updateUsers";
    LOGGER.entering(CLASS_NAME, METHOD);

    String userSelectionFormula = connectorSession.getUserSelectionFormula();
    String userNameFormula = connectorSession.getUserNameFormula();
    if (LOGGER.isLoggable(Level.FINEST)) {
      LOGGER.logp(Level.FINEST, CLASS_NAME, METHOD,
          "User selection formula is: " + userSelectionFormula
          + "\nUser name formula is: " + userNameFormula);
    }
    NotesView serverAccessView = directoryDatabase.getView(
        NCCONST.DIRVIEW_SERVERACCESS);
    serverAccessView.refresh();
    NotesDocument personDoc = null;
    try {
      for (personDoc = peopleGroupsView.getFirstDocument();
           personDoc != null;
           personDoc = getNextDocument(peopleGroupsView, personDoc)) {
        String fullName = null;
        try {
          if (!personDoc.getItemValueString(NCCONST.ITMFORM).contentEquals(
                  NCCONST.DIRFORM_PERSON)) {
            continue;
          }
          // The first value in this field is the Notes name; other
          // names may be present.
          fullName = personDoc.getItemValue(NCCONST.PITM_FULLNAME)
              .firstElement().toString().toLowerCase();
          if (LOGGER.isLoggable(Level.FINEST)) {
            LOGGER.logp(Level.FINEST, CLASS_NAME, METHOD,
                "Processing user: " + fullName);
          }
          // Get their PVI
          String pvi = evaluatePvi(userNameFormula, personDoc);
          if (0 == pvi.length()) {
            LOGGER.logp(Level.WARNING, CLASS_NAME, METHOD,
                "Could not evaluate PVI username for: " + fullName);
            continue;
          }
          if (LOGGER.isLoggable(Level.FINEST)) {
            LOGGER.logp(Level.FINEST, CLASS_NAME, METHOD, "PVI: " + pvi);
          }
          // Does this person match the selection formula?
          boolean selected = checkPersonSelectionFormula(userSelectionFormula,
              personDoc);
          if (!selected) {
            if (LOGGER.isLoggable(Level.FINEST)) {
              LOGGER.logp(Level.FINEST, CLASS_NAME, METHOD,
                  "User not selected: " + fullName);
            }
            continue;
          }
          updateUser(personDoc, fullName, pvi, serverAccessView);
        } catch (SQLException e) {
          LOGGER.logp(Level.WARNING, CLASS_NAME, METHOD,
              "Failed to update user cache" +
              (fullName != null ? " for " + fullName : ""), e);
        }
      }
    } finally {
      Util.recycle(personDoc);
      LOGGER.exiting(CLASS_NAME, METHOD);
    }
  }

  private void updateUser(NotesDocument personDoc,
      String fullName, String pvi, NotesView serverAccessView)
      throws SQLException, RepositoryException {
    final String METHOD = "updateUser";
    LOGGER.entering(CLASS_NAME, METHOD);

    PreparedStatement pstmt = null;
    try {
      conn.setAutoCommit(false);

      // Create the user record (if needed).
      long userId = verifyUserExists(fullName, pvi, true);
      Set<Long> parentGroups = new LinkedHashSet<Long>();
      getParentGroupsForUser(fullName, parentGroups, serverAccessView);
      getParentGroupsForUser(NotesAuthorizationManager.getCommonName(fullName),
          parentGroups, serverAccessView);
      // getGroupsFromDN will add the DN-based groups to the
      // group cache if they don't exist, so we want it in the
      // transaction.
      getGroupsFromDN(fullName, parentGroups);
      // Delete previous user/group records for this user.
      pstmt = conn.prepareStatement(
          "delete from " + userGroupsTableName
          + " where userid = ?");
      pstmt.setLong(1, userId);
      pstmt.executeUpdate();
      // Update user/group records.
      pstmt = conn.prepareStatement("insert into " + userGroupsTableName
          + " (userid, groupid) values(?, ?)");
      pstmt.setLong(1, userId);
      for (Long groupId : parentGroups) {
        pstmt.setLong(2, groupId);
        pstmt.executeUpdate();
      }
      conn.commit();
    } catch (SQLException e) {
      LOGGER.logp(Level.WARNING, CLASS_NAME, METHOD,
          "Error updating user data for: " + fullName, e);
      conn.rollback();
      Util.close(pstmt);
    } finally {
      conn.setAutoCommit(true);
      LOGGER.exiting(CLASS_NAME, METHOD);
    }
  }

  @SuppressWarnings("unchecked")
  private void getParentGroupsForUser(String userName,
      Set<Long> parentGroups, NotesView serverAccessView)
      throws RepositoryException {
    final String METHOD = "getParentGroupsForUser";
    LOGGER.entering(CLASS_NAME, METHOD);

    NotesViewNavigator nvnAccess = null;
    NotesViewEntry nveAccessEntry = null;
    try {
      nvnAccess = serverAccessView.createViewNavFromCategory(userName);
      for (nveAccessEntry = nvnAccess.getFirst();
           nveAccessEntry != null;
           nveAccessEntry = getNextViewEntry(nvnAccess, nveAccessEntry)) {
        NotesDocument accessdoc = nveAccessEntry.getDocument();
        try {
          String groupName =
              accessdoc.getItemValueString(NCCONST.GITM_LISTNAME);
          PreparedStatement pstmt = null;
          try {
            pstmt = conn.prepareStatement("select groupId from "
                + groupTableName + " where groupName = ?");
            pstmt.setString(1, groupName);
            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
              long id = rs.getLong(1);
              parentGroups.add(id);
              getParentGroupsForGroup(id, parentGroups);
            } else {
              LOGGER.logp(Level.WARNING, CLASS_NAME, METHOD,
                  "No group record for group: " + groupName);
            }
          } catch (SQLException e) {
            LOGGER.logp(Level.WARNING, CLASS_NAME, METHOD,
                "Failure looking up group record for " + groupName, e);
          } finally {
            Util.close(pstmt);
          }
        } finally {
          Util.recycle(accessdoc);
        }
      }
    } finally {
      Util.recycle(nveAccessEntry);
      Util.recycle(nvnAccess);
      LOGGER.exiting(CLASS_NAME, METHOD);
    }
  }

  private void getParentGroupsForGroup(long groupId,
      Set<Long> parentGroups) throws RepositoryException {
    final String METHOD = "getParentGroupsForGroup";
    LOGGER.entering(CLASS_NAME, METHOD);

    PreparedStatement pstmt = null;
    try {
      pstmt = conn.prepareStatement("select parentgroupid from "
          + groupChildrenTableName + " where childgroupid = ?");
      pstmt.setLong(1, groupId);
      ResultSet rs = pstmt.executeQuery();
      while (rs.next()) {
        long id = rs.getLong(1);
        parentGroups.add(id);
        getParentGroupsForGroup(id, parentGroups);
      }
    } catch (SQLException e) {
      LOGGER.logp(Level.WARNING, CLASS_NAME, METHOD,
          "Failure getting parent groups for " + groupId, e);
      throw new RepositoryException(e);
    } finally {
      Util.close(pstmt);
      LOGGER.exiting(CLASS_NAME, METHOD);
    }
  }

  private void getGroupsFromDN(String dn, Set<Long> groups) {
    final String METHOD = "getGroupsFromDN";
    LOGGER.entering(CLASS_NAME, METHOD);

    // TODO: use the Name class to parse the name?
    for (int index = dn.indexOf('/'); index != -1; index = dn.indexOf('/')) {
      try {
        String ou = dn.substring(index + 1);
        LOGGER.logp(Level.FINER, CLASS_NAME, METHOD,
            "Group list adding OU " + ou);
        long groupId = verifyGroupExists(ou, true);
        markAsPseudoGroup(groupId, ou);
        groups.add(groupId);
        dn = ou;
      } catch (SQLException e) {
        LOGGER.logp(Level.WARNING, CLASS_NAME, METHOD,
            "Error creating group from dn: " + dn, e);
      } catch (RepositoryException e) {
        LOGGER.logp(Level.WARNING, CLASS_NAME, METHOD,
            "Error creating group from dn: " + dn, e);
      }
    }
    LOGGER.exiting(CLASS_NAME, METHOD);
  }

  private void markAsPseudoGroup(long groupId, String groupName) {
    final String METHOD = "markAsPseudoGroup";
    LOGGER.entering(CLASS_NAME, METHOD);

    Statement stmt = null;
    try {
      if (LOGGER.isLoggable(Level.FINEST)) {
        LOGGER.logp(Level.FINEST, CLASS_NAME, METHOD,
            "Marking group as pseudo-group: " + groupName + "/" + groupId);
      }
      stmt = conn.createStatement();
      int result = stmt.executeUpdate("update " + groupTableName
          + " set pseudogroup = true where groupid = " + groupId);
      if (result != 1) {
        LOGGER.logp(Level.WARNING, CLASS_NAME, METHOD,
            "Failed to flag group as pseudo-group: " + groupName);
      }
    } catch (SQLException e) {
      LOGGER.logp(Level.WARNING, CLASS_NAME, METHOD,
          "Failed to flag group as pseudo-group: " + groupName, e);
    } finally {
      Util.close(stmt);
      LOGGER.exiting(CLASS_NAME, METHOD);
    }
  }

  private long verifyUserExists(String notesName, String pvi,
      boolean createIfNotExists) throws SQLException, RepositoryException {
    final String METHOD = "verifyUserExists";
    LOGGER.entering(CLASS_NAME, METHOD);

    try {
      String userLookupSql;
      String key;
      if (notesName != null) {
        if (notesName.startsWith("cn=")) {
          userLookupSql = "select * from " + userTableName
              + " where notesname = ?";
          key = notesName;
        } else {
          userLookupSql = "select * from " + userTableName
              + " where notesname like ?";
          key = "cn=" + notesName + "/%";
        }
      } else if (pvi != null) {
        userLookupSql = "select * from " + userTableName
            + " where gsaname = ?";
        key = pvi;
      } else {
        throw new RepositoryException("Attempted user lookup without a key");
      }
      if (LOGGER.isLoggable(Level.FINEST)) {
        LOGGER.logp(Level.FINEST, CLASS_NAME, METHOD,
            "Looking up user with SQL: [" + userLookupSql + "] and key: "
            + key);
      }
      PreparedStatement pstmt = conn.prepareStatement(userLookupSql,
          ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
      ResultSet rs = null;
      ResultSet generatedKeys = null;
      try {
        pstmt.setString(1, key);
        rs = pstmt.executeQuery();
        if (rs.next()) {
          // See if we need to update the pvi
          if (pvi != null && !pvi.equals(rs.getString("gsaname"))) {
            rs.updateString("gsaname", pvi); // Support formula changes.
            rs.updateRow();
          }
          return rs.getLong("userid");
        }
        if (!createIfNotExists) {
          return -1L;
        }
        Util.close(pstmt);
        rs = null;
        pstmt = conn.prepareStatement(
            "insert into " + userTableName
            + "(notesname, gsaname) values (?, ?)",
            Statement.RETURN_GENERATED_KEYS);
        pstmt.setString(1, notesName);
        pstmt.setString(2, pvi);
        int rows = pstmt.executeUpdate();
        if (rows == 0) {
          throw new RepositoryException(
              "Failed to create user record for " + notesName);
        }
        generatedKeys = pstmt.getGeneratedKeys();
        if (generatedKeys.next()) {
          return generatedKeys.getLong(1);
        } else {
          throw new RepositoryException(
              "Failed to retrieve key for " + notesName);
        }
      } finally {
        Util.close(generatedKeys);
        Util.close(rs);
        Util.close(pstmt);
      }
    } finally {
      LOGGER.exiting(CLASS_NAME, METHOD);
    }
  }

  // Update roles

  /**
   * Loop over the databases configured for crawling. For each
   * database, cache information about roles assigned to users or
   * groups in the ACL.
   */
  @VisibleForTesting
  void updateRoles() throws RepositoryException {
    final String METHOD = "updateRoles";
    LOGGER.entering(CLASS_NAME, METHOD);

    NotesView connectorCrawlDatabaseView = null;
    NotesDocument connectorCrawlDatabaseDoc = null;
    try {
      connectorCrawlDatabaseView =
          connectorDatabase.getView(NCCONST.VIEWDATABASES);
      connectorCrawlDatabaseView.refresh();

      Set<String> replicaIds = new LinkedHashSet<String>();
      for (connectorCrawlDatabaseDoc =
               connectorCrawlDatabaseView.getFirstDocument();
           connectorCrawlDatabaseDoc != null;
           connectorCrawlDatabaseDoc = getNextDocument(
               connectorCrawlDatabaseView, connectorCrawlDatabaseDoc)) {
        NotesDatabase crawlDatabase = null;
        try {
          String databaseName = connectorCrawlDatabaseDoc.getItemValueString(
              NCCONST.DITM_DBNAME);
          String replicaId = connectorCrawlDatabaseDoc.getItemValueString(
              NCCONST.DITM_REPLICAID);
          LOGGER.logp(Level.FINE, CLASS_NAME, METHOD,
              "Updating roles for database: " + databaseName);
          replicaIds.add(replicaId);

          // TODO: is there anything that would cause us to skip
          // checking roles for this database? Or remove all
          // role-related records for this database?

          crawlDatabase = notesSession.getDatabase(null, null);
          crawlDatabase.openByReplicaID(
              connectorCrawlDatabaseDoc.getItemValueString(NCCONST.DITM_SERVER),
              replicaId);
          if (!crawlDatabase.isOpen()) {
            LOGGER.logp(Level.FINE, CLASS_NAME, METHOD,
                "Database could not be opened: " + databaseName);
            continue;
          }
          updateRolesForDatabase(crawlDatabase, replicaId);
        } finally {
          Util.recycle(crawlDatabase);
        }
      }
      checkDatabaseDeletions(replicaIds);
    } catch (RepositoryException e) {
      LOGGER.logp(Level.WARNING, CLASS_NAME, METHOD,
          "Error updating roles", e);
    } finally {
      Util.recycle(connectorCrawlDatabaseDoc);
      Util.recycle(connectorCrawlDatabaseView);
      LOGGER.exiting(CLASS_NAME, METHOD);
    }
  }

  private void updateRolesForDatabase(NotesDatabase crawlDatabase,
      String databaseReplicaId) {
    final String METHOD = "updateRolesForDatabase";
    LOGGER.entering(CLASS_NAME, METHOD);

    NotesACL acl = null;
    NotesACLEntry aclEntry = null;
    try {
      conn.setAutoCommit(false);
      deleteRolesForDatabase(databaseReplicaId);
      acl = crawlDatabase.getACL();
      for (aclEntry = acl.getFirstEntry();
           aclEntry != null;
           aclEntry = getNextAclEntry(acl, aclEntry)) {
        Vector roles = aclEntry.getRoles();
        if (LOGGER.isLoggable(Level.FINEST)) {
          LOGGER.logp(Level.FINEST, CLASS_NAME, METHOD,
              "Acl entry: " + aclEntry.getName() + "; with roles: " + roles);
        }
        int roleType = aclEntry.getUserType();
        switch (roleType) {
          case NotesACLEntry.TYPE_PERSON:
            updateRolesForUser(aclEntry.getName(), databaseReplicaId, roles);
            break;
          case NotesACLEntry.TYPE_SERVER:
          case NotesACLEntry.TYPE_SERVER_GROUP:
            break;
          default: // Treat all other cases as groups.
            updateRolesForGroup(aclEntry.getName(), databaseReplicaId, roles);
            break;
        }
      }
      conn.commit();
    } catch (SQLException e) {
      try {
        conn.rollback();
      } catch (SQLException e1) {
        LOGGER.logp(Level.WARNING, CLASS_NAME, METHOD,
            "Rollback failed", e1);
      }
      LOGGER.logp(Level.WARNING, CLASS_NAME, METHOD,
          "Failed to update role data for database: " + databaseReplicaId, e);
    } catch (RepositoryException e) {
        try {
          conn.rollback();
      } catch (SQLException e1) {
        LOGGER.logp(Level.WARNING, CLASS_NAME, METHOD,
            "Rollback failed", e1);
      }
      LOGGER.logp(Level.WARNING, CLASS_NAME, METHOD,
          "Failed to update role data for database: " + databaseReplicaId, e);
    } finally {
      try {
        conn.setAutoCommit(true);
      } catch (SQLException e) {
        LOGGER.logp(Level.WARNING, CLASS_NAME, METHOD,
            "Failed to reset autocommit", e);
      }
      Util.recycle(aclEntry);
      Util.recycle(acl);
      LOGGER.exiting(CLASS_NAME, METHOD);
    }
  }

  private void deleteRolesForDatabase(String databaseReplicaId)
      throws SQLException {
    final String METHOD = "deleteRolesForDatabase";
    LOGGER.entering(CLASS_NAME, METHOD);

    PreparedStatement pstmt1 = null;
    PreparedStatement pstmt2 = null;
    PreparedStatement pstmt3 = null;
    try {
      pstmt1 = conn.prepareStatement("delete from " + userRolesTableName
          + " where roleid in (select roleid from " + roleTableName
          + " where replicaid = ?)");
      pstmt2 = conn.prepareStatement("delete from " + groupRolesTableName
          + " where roleid in (select roleid from " + roleTableName
          + " where replicaid = ?)");
      pstmt3 = conn.prepareStatement("delete from " + roleTableName
          + " where replicaid = ?");
      pstmt1.setString(1, databaseReplicaId);
      pstmt1.executeUpdate();
      pstmt2.setString(1, databaseReplicaId);
      pstmt2.executeUpdate();
      pstmt3.setString(1, databaseReplicaId);
      pstmt3.executeUpdate();
    } finally {
      Util.close(pstmt1);
      Util.close(pstmt2);
      Util.close(pstmt3);
      LOGGER.exiting(CLASS_NAME, METHOD);
    }
  }

  private void updateRolesForUser(String notesName, String databaseReplicaId,
      Vector roles) throws SQLException, RepositoryException {
    final String METHOD = "updateRolesForUser";
    LOGGER.entering(CLASS_NAME, METHOD);

    try {
      long userId = verifyUserExists(notesName.toLowerCase(), null, false);
      if (-1L == userId) {
        LOGGER.logp(Level.FINEST, CLASS_NAME, METHOD,
            "ACL user not in connector user cache: " + notesName);
        return;
      }
      PreparedStatement pstmt = null;
      try {
        pstmt = conn.prepareStatement("insert into " + userRolesTableName
            + " (userid, roleid) values(?, ?)");
        pstmt.setLong(1, userId);
        for (Object role : roles) {
          String roleName = role.toString();
          long roleId = verifyRoleExists(roleName, databaseReplicaId, true);
          pstmt.setLong(2, roleId);
          pstmt.executeUpdate();
        }
      } finally {
        Util.close(pstmt);
      }
    } finally {
      LOGGER.exiting(CLASS_NAME, METHOD);
    }
  }

  private void updateRolesForGroup(String groupName, String databaseReplicaId,
      Vector roles) throws SQLException, RepositoryException {
    final String METHOD = "updateRolesForGroup";
    LOGGER.entering(CLASS_NAME, METHOD);

    try {
      long groupId = verifyGroupExists(groupName, false);
      if (-1L == groupId) {
        LOGGER.logp(Level.FINEST, CLASS_NAME, METHOD,
            "ACL group not in connector group cache: " + groupName);
        return;
      }
      PreparedStatement pstmt = null;
      try {
        pstmt = conn.prepareStatement("insert into " + groupRolesTableName
            + " (groupid, roleid) values(?, ?)");
        pstmt.setLong(1, groupId);
        for (Object role : roles) {
          String roleName = role.toString();
          long roleId = verifyRoleExists(roleName, databaseReplicaId, true);
          pstmt.setLong(2, roleId);
          pstmt.executeUpdate();
        }
      } finally {
        Util.close(pstmt);
      }
    } finally {
      LOGGER.exiting(CLASS_NAME, METHOD);
    }
  }

  private long verifyRoleExists(String roleName, String databaseReplicaId,
      boolean createIfNotExists) throws SQLException, RepositoryException {
    final String METHOD = "verifyRoleExists";
    LOGGER.entering(CLASS_NAME, METHOD);

    try {
      PreparedStatement pstmt = conn.prepareStatement(
          "select * from " + roleTableName + " where rolename = ?"
          + " and replicaid = ?",
          ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
      ResultSet generatedKeys = null;
      try {
        pstmt.setString(1, roleName);
        pstmt.setString(2, databaseReplicaId);
        ResultSet rs = pstmt.executeQuery();
        if (rs.next()) {
          return rs.getLong("roleid");
        }
        if (!createIfNotExists) {
          return -1L;
        }
        rs.close();
        pstmt.close();
        pstmt = conn.prepareStatement("insert into " + roleTableName
            + "(rolename, replicaId) values (?, ?)",
            Statement.RETURN_GENERATED_KEYS);
        pstmt.setString(1, roleName);
        pstmt.setString(2, databaseReplicaId);
        int rows = pstmt.executeUpdate();
        if (rows == 0) {
          throw new RepositoryException(
              "Failed to create role record for " + roleName);
        }
        generatedKeys = pstmt.getGeneratedKeys();
        if (generatedKeys.next()) {
          return generatedKeys.getLong(1);
        } else {
          throw new RepositoryException(
              "Failed to retrieve key for " + roleName);
        }
      } finally {
        Util.close(generatedKeys);
        Util.close(pstmt);
      }
    } finally {
      LOGGER.exiting(CLASS_NAME, METHOD);
    }
  }

  /**
   * Remove any role records with a replica id not in the
   * parameter list.
   */
  @VisibleForTesting
  void checkDatabaseDeletions(Set currentReplicaIds) {
    final String METHOD = "checkDatabaseDeletions";
    LOGGER.entering(CLASS_NAME, METHOD);

    Statement stmt = null;
    try {
      Set<String> replicaIdsToDelete = new LinkedHashSet<String>();
      stmt = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
          ResultSet.CONCUR_READ_ONLY);
      ResultSet rs = stmt.executeQuery("select distinct(replicaid)"
          + " from " + roleTableName);
      while (rs.next()) {
        String replicaId = rs.getString(1);
        if (!currentReplicaIds.contains(replicaId)) {
          replicaIdsToDelete.add(replicaId);
        }
      }
      if (replicaIdsToDelete.size() > 0) {
        LOGGER.logp(Level.FINE, CLASS_NAME, METHOD,
            "Found role cache data for database(s) that aren't" +
            " in the connector's crawl list any more: " + replicaIdsToDelete);
        conn.setAutoCommit(false);
        try {
          for (String replicaId : replicaIdsToDelete) {
            deleteRolesForDatabase(replicaId);
          }
          conn.commit();
        } catch (SQLException e) {
          LOGGER.logp(Level.WARNING, CLASS_NAME, METHOD,
              "Failure deleting roles for database(s)", e);
          conn.rollback();
        } finally {
          conn.setAutoCommit(true);
        }
      }
    } catch (SQLException e) {
      LOGGER.logp(Level.WARNING, CLASS_NAME, METHOD,
          "Database error", e);
    } finally {
      Util.close(stmt);
      LOGGER.exiting(CLASS_NAME, METHOD);
    }
  }

  // Delete data

  /**
   * Check each user in the cache against the view
   * NCCONST.DIRVIEW_VIMUSERS. If the cached user is not in the
   * Notes view, delete them from the cache.
   */
  @VisibleForTesting
  void checkUserDeletions() throws RepositoryException {
    final String METHOD = "checkUserDeletions";
    LOGGER.entering(CLASS_NAME, METHOD);

    String userSelectionFormula = connectorSession.getUserSelectionFormula();

    // TODO: why do we have to use this view and an abbreviated
    // full name as opposed to just using the people/groups view
    // we use elsewhere?
    NotesView usersView = directoryDatabase.getView(NCCONST.DIRVIEW_VIMUSERS);
    usersView.refresh();
    ArrayList<Long> usersToDelete = new ArrayList<Long>();
    Statement stmt = null;
    try {
      stmt = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
          ResultSet.CONCUR_READ_ONLY);
      ResultSet rs = stmt.executeQuery("select userid,notesname from "
          + userTableName);
      while (rs.next()) {
        long userId;
        String fullName;
        try {
          userId = rs.getLong(1);
          fullName = rs.getString(2);
        } catch (SQLException e) {
          LOGGER.logp(Level.WARNING, CLASS_NAME, METHOD,
              "Failure reading user table data", e);
          continue;
        }
        String abbrevFormula = String.format("@Name([ABBREVIATE];\"%s\")",
            fullName);
        String key = notesSession.evaluate(abbrevFormula).elementAt(0)
            .toString();
        NotesDocument notesUserDoc = usersView.getDocumentByKey(key);
        if (notesUserDoc == null) {
          // This person or group no longer exists. Remove them
          LOGGER.logp(Level.INFO, CLASS_NAME, METHOD,
              "User no longer exists in source directory"
              + " and will be deleted: " + key);
          usersToDelete.add(userId);
        } else {
          // Do an additional check for Persons to make sure they
          // still meet the selection criteria
          if (!checkPersonSelectionFormula(userSelectionFormula,
              notesUserDoc)) {
            LOGGER.logp(Level.INFO, CLASS_NAME, METHOD,
                "User no longer meets selection criteria"
                + " and will be deleted: " + key);
            usersToDelete.add(userId);
          }
          notesUserDoc.recycle();
        }
      }
    } catch (SQLException e) {
      LOGGER.logp(Level.WARNING, CLASS_NAME, METHOD,
          "Error checking deletions", e);
    } finally {
      usersView.recycle();
      Util.close(stmt);
    }

    for (Long userId : usersToDelete) {
      try {
        removeUser(userId);
      } catch (SQLException e) {
        LOGGER.logp(Level.WARNING, CLASS_NAME, METHOD,
            "Error removing user: " + userId, e);
      }
    }
    LOGGER.exiting(CLASS_NAME, METHOD);
  }

  /**
   * Check each group in the cache against the view
   * NCCONST.DIRVIEW_VIMGROUPS. If the cached group is not in the
   * Notes view, delete it from the cache.
   */
  @VisibleForTesting
  void checkGroupDeletions() throws RepositoryException {
    final String METHOD = "checkGroupDeletions";
    LOGGER.entering(CLASS_NAME, METHOD);

    NotesView groupView = directoryDatabase.getView(NCCONST.DIRVIEW_VIMGROUPS);
    groupView.refresh();
    ArrayList<Long> groupsToDelete = new ArrayList<Long>();
    Statement stmt = null;
    try {
      stmt = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
          ResultSet.CONCUR_READ_ONLY);
      ResultSet rs = stmt.executeQuery(
          "select groupid,groupname,pseudogroup from " + groupTableName);
      while (rs.next()) {
        long groupId;
        String groupName;
        boolean pseudoGroup = false;
        try {
          groupId = rs.getLong(1);
          groupName = rs.getString(2);
          pseudoGroup = rs.getBoolean(3);
        } catch (SQLException e) {
          LOGGER.logp(Level.WARNING, CLASS_NAME, METHOD,
              "Failure reading group table data", e);
          continue;
        }

        if (pseudoGroup) {
          if (LOGGER.isLoggable(Level.FINEST)) {
            LOGGER.logp(Level.FINEST, CLASS_NAME, METHOD,
                "Skipping deletion check for pseudo-group: " + groupName);
          }
          continue;
        }
        NotesDocument notesGroupDoc = groupView.getDocumentByKey(groupName);
        if (notesGroupDoc == null) {
          // This group no longer exists.
          LOGGER.logp(Level.INFO, CLASS_NAME, METHOD,
              "Group no longer exists in source directory"
              + " and will be deleted: " + groupName);
          groupsToDelete.add(groupId);
        }
        Util.recycle(notesGroupDoc);
      }
    } catch (SQLException e) {
      LOGGER.logp(Level.WARNING, CLASS_NAME, METHOD,
          "Error checking deletions", e);
    } finally {
      groupView.recycle();
      Util.close(stmt);
    }

    for (Long groupId : groupsToDelete) {
      try {
        removeGroup(groupId);
      } catch (SQLException e) {
        LOGGER.logp(Level.WARNING, CLASS_NAME, METHOD,
            "Error removing group: " + groupId, e);
      }
    }
    LOGGER.exiting(CLASS_NAME, METHOD);
  }

  private void removeUser(String notesName) throws SQLException {
    final String METHOD = "removeUser";
    LOGGER.entering(CLASS_NAME, METHOD);
    LOGGER.logp(Level.FINE, CLASS_NAME, METHOD,
        "Removing user: " + notesName);

    PreparedStatement pstmt = conn.prepareStatement("select userid from "
        + userTableName + " where notesname = ?",
        ResultSet.TYPE_SCROLL_INSENSITIVE,
        ResultSet.CONCUR_READ_ONLY);
    long userId = -1;
    try {
      pstmt.setString(1, notesName);
      ResultSet rs = pstmt.executeQuery();
      if (rs.next()) {
        userId = rs.getLong(1);
      }
    } finally {
      Util.close(pstmt);
    }
    if (userId != -1) {
      removeUser(userId);
    } else {
      LOGGER.logp(Level.FINE, CLASS_NAME, METHOD,
          "Unable to find user data to remove: " + notesName);
    }
    LOGGER.exiting(CLASS_NAME, METHOD);
  }

  private void removeUser(long userId) throws SQLException {
    final String METHOD = "removeUser";
    LOGGER.entering(CLASS_NAME, METHOD);
    LOGGER.logp(Level.FINE, CLASS_NAME, METHOD,
        "Removing user: " + userId);

    try {
      conn.setAutoCommit(false);
      executeUpdateWithIds("delete from " + userGroupsTableName
          + " where userid = ?", userId);
      executeUpdateWithIds("delete from " + userRolesTableName
          + " where userid = ?", userId);
      executeUpdateWithIds("delete from " + userTableName
          + " where userid = ?", userId);
      conn.commit();
    } catch (SQLException e) {
      LOGGER.logp(Level.WARNING, CLASS_NAME, METHOD,
          "Caught exception", e);
      conn.rollback();
    } finally {
      conn.setAutoCommit(true);
    }
    LOGGER.exiting(CLASS_NAME, METHOD);
  }

  private void removeGroup(long groupId) throws SQLException {
    final String METHOD = "removeGroup";
    LOGGER.entering(CLASS_NAME, METHOD);

    try {
      conn.setAutoCommit(false);
      executeUpdateWithIds("delete from " + groupChildrenTableName
          + " where parentgroupid = ? or childgroupid = ?",
          groupId, groupId);
      executeUpdateWithIds("delete from " + groupRolesTableName
          + " where groupid = ?", groupId);
      executeUpdateWithIds("delete from " + userGroupsTableName
          + " where groupid = ?", groupId);
      executeUpdateWithIds("delete from " + groupTableName
          + " where groupid = ?", groupId);
      conn.commit();
    } catch (SQLException e) {
      LOGGER.logp(Level.WARNING, CLASS_NAME, METHOD,
          "Caught exception", e);
      conn.rollback();
    } finally {
      conn.setAutoCommit(true);
    }
  }

  private int executeUpdateWithIds(String sql, long... ids)
      throws SQLException {
    PreparedStatement pstmt = conn.prepareStatement(sql);
    try {
      for (int i = 0; i < ids.length; i++) {
        pstmt.setLong(i + 1, ids[i]);
      }
      return pstmt.executeUpdate();
    } finally {
      Util.close(pstmt);
    }
  }

  // Manage update interval.

  private void setLastCacheUpdate() {
    final String METHOD = "setLastCacheUpdate";
    LOGGER.entering(CLASS_NAME, METHOD);

    NotesDateTime now = null;
    NotesView systemView = null;
    NotesDocument systemDoc = null;
    try {
      now = notesSession.createDateTime("1/1/1900");
      now.setNow();
      systemView = connectorDatabase.getView(NCCONST.VIEWSYSTEMSETUP);
      systemDoc = systemView.getFirstDocument();
      if (systemDoc == null) {
        LOGGER.logp(Level.SEVERE, CLASS_NAME, METHOD,
            "System configuration document not found.");
        return;
      }
      systemDoc.replaceItemValue(NCCONST.SITM_LASTCACHEUPDATE, now);
      systemDoc.save(true);
      LOGGER.logp(Level.INFO, CLASS_NAME, METHOD,
          "Directory Cache last update time set to " + now.toString());
    } catch (RepositoryException e) {
      LOGGER.log(Level.SEVERE, CLASS_NAME, e);
    } finally {
      Util.recycle(systemDoc);
      Util.recycle(systemView);
      Util.recycle(now);
    }
    LOGGER.exiting(CLASS_NAME, METHOD);
  }

  private boolean shouldUpdate(NotesDatabase connectorDatabase)
      throws RepositoryException {
    final String METHOD = "shouldUpdate";
    LOGGER.entering(CLASS_NAME, METHOD);

    boolean needToUpdate = true;

    NotesDateTime lastCacheUpdate = null;
    NotesDateTime now = null;
    NotesView systemView = null;
    NotesDocument systemDoc = null;
    Vector<?> vecLastCacheUpdate = null;
    try {
      lastCacheUpdate = notesSession.createDateTime("1/1/2010");
      now = notesSession.createDateTime("1/1/1900");
      now.setNow();

      systemView = connectorDatabase.getView(NCCONST.VIEWSYSTEMSETUP);
      systemDoc = systemView.getFirstDocument();
      if (systemDoc == null) {
        LOGGER.logp(Level.SEVERE, CLASS_NAME, METHOD,
            "System configuration document not found.");
        return false;
      }

      // Get the update interval from the system configuration
      int cacheUpdateInterval = connectorSession.getCacheUpdateInterval();
      vecLastCacheUpdate = systemDoc
          .getItemValue(NCCONST.SITM_LASTCACHEUPDATE);
      if (vecLastCacheUpdate.size() > 0) {
        LOGGER.logp(Level.FINE, CLASS_NAME, METHOD,
            "vecLastCacheUpdate is " + vecLastCacheUpdate);
        lastCacheUpdate = (NotesDateTime) vecLastCacheUpdate.firstElement();
        LOGGER.logp(Level.FINE, CLASS_NAME, METHOD,
            "Last directory cache update time is: " + lastCacheUpdate);
      }

      double elapsedMinutes = now.timeDifference(lastCacheUpdate) / 60;
      LOGGER.logp(Level.FINE, CLASS_NAME, METHOD,
          "Time difference since last directory cache update is: "
          + elapsedMinutes);

      // Check poll interval
      if (cacheUpdateInterval > elapsedMinutes) {
        LOGGER.logp(Level.FINE, CLASS_NAME, METHOD,
            "Directory cache poll interval has not yet elapsed.");
        needToUpdate = false;
      }
    } finally {
      Util.recycle(now);
      Util.recycle(notesSession, vecLastCacheUpdate);
      Util.recycle(lastCacheUpdate);
      Util.recycle(systemDoc);
      Util.recycle(systemView);
    }
    LOGGER.exiting(CLASS_NAME, METHOD);
    return needToUpdate;
  }

  /**
   * Use the given formula to construct a PVI from the Notes user
   * document.
   */
  private String evaluatePvi(String userNameFormula, NotesDocument doc)
      throws RepositoryException {
    final String METHOD = "evaluatePvi";

    Vector<?> vecEvalResult = notesSession.evaluate(userNameFormula, doc);
    // Make sure we don't get an empty vector.
    if (vecEvalResult != null && vecEvalResult.size() > 0) {
      return (vecEvalResult.elementAt(0).toString());
    }
    LOGGER.logp(Level.WARNING, CLASS_NAME, METHOD,
        "Failed to evaluate formula: " + userNameFormula);
    return "";
  }

  /**
   * Use the given formula to decide if a Notes user should be
   * included in the connector's user cache. The Notes formula
   * should return 1 or 0.
   */
  @SuppressWarnings("unchecked")
  private boolean checkPersonSelectionFormula(String userSelectionFormula,
      NotesDocument personDoc) throws RepositoryException {
    Vector<Double> vecEvalResult = (Vector<Double>) notesSession.evaluate(
        userSelectionFormula, personDoc);
    // A Selection formula will return a vector of doubles.
    return (1 == vecEvalResult.elementAt(0).intValue());
  }

  private boolean isAccessControlGroup(NotesDocument groupDoc)
      throws RepositoryException {
    if (!groupDoc.getItemValueString(NCCONST.ITMFORM).contentEquals(
            NCCONST.DIRFORM_GROUP)) {
      return false;
    }
    // Only process access control type groups
    String groupType = groupDoc.getItemValueString(NCCONST.GITM_GROUPTYPE);
    if (!NCCONST.DIR_ACCESSCONTROLGROUPTYPES.contains(groupType)) {
      return false;
    }
    return true;
  }

  // Helpers

  private NotesDocument getNextDocument(NotesView view, NotesDocument doc)
      throws RepositoryException {
    NotesDocument nextDoc = view.getNextDocument(doc);
    doc.recycle();
    return nextDoc;
  }

  private NotesViewEntry getNextViewEntry(NotesViewNavigator viewNav,
      NotesViewEntry viewEntry) throws RepositoryException {
    NotesViewEntry nextEntry = viewNav.getNext(viewEntry);
    Util.recycle(viewEntry);
    return nextEntry;
  }

  private NotesACLEntry getNextAclEntry(NotesACL acl, NotesACLEntry aclEntry)
      throws RepositoryException {
    NotesACLEntry nextEntry = acl.getNextEntry(aclEntry);
    Util.recycle(aclEntry);
    return nextEntry;
  }

  // Database setup

  @VisibleForTesting
  void initializeUserCache() throws RepositoryException {
    final String METHOD = "initializeUserCache";
    Connection conn = null;
    try {
      JdbcDatabase jdbcDatabase =
          connectorSession.getConnector().getJdbcDatabase();
      // Notes user names don't have a simple defined max
      // size. There are limits for each component (name, org
      // unit, org). For now, we're going with "as big as a
      // varchar can be".
      jdbcDatabase.verifyTableExists(userTableName, new String[] {
          "create table " + userTableName
          + " (userid long auto_increment primary key,"
          + " gsaname varchar(128), notesname varchar(254))"});
      LOGGER.logp(Level.INFO, CLASS_NAME, METHOD,
          "Created/verified table: " + userTableName);

      // Group names have a max size of 63, but we also create
      // groups based on DN components, so make the groupname
      // field larger than would otherwise be needed.
      jdbcDatabase.verifyTableExists(groupTableName, new String[] {
          "create table " + groupTableName
          + " (groupid long auto_increment primary key,"
          + " groupname varchar(254), pseudogroup boolean)"});
       LOGGER.logp(Level.INFO, CLASS_NAME, METHOD,
           "Created/verified table: " + groupTableName);

      // Role names have a max size of 15.
      jdbcDatabase.verifyTableExists(roleTableName, new String[] {
          "create table " + roleTableName
          + " (roleid long auto_increment primary key,"
          + " rolename varchar(32), replicaid varchar(32))"});
       LOGGER.logp(Level.INFO, CLASS_NAME, METHOD,
           "Created/verified table: " + roleTableName);

      jdbcDatabase.verifyTableExists(userGroupsTableName, new String[] {
          "create table " + userGroupsTableName + " (userid long,"
          + " groupid long)"});
       LOGGER.logp(Level.INFO, CLASS_NAME, METHOD,
           "Created/verified table: " + userGroupsTableName);

      jdbcDatabase.verifyTableExists(userRolesTableName, new String[] {
          "create table " + userRolesTableName + " (userid long,"
          + " roleid long)"});
       LOGGER.logp(Level.INFO, CLASS_NAME, METHOD,
           "Created/verified table: " + userRolesTableName);

      jdbcDatabase.verifyTableExists(groupRolesTableName, new String[] {
          "create table " + groupRolesTableName + " (groupid long,"
          + " roleid long)"});
       LOGGER.logp(Level.INFO, CLASS_NAME, METHOD,
           "Created/verified table: " + groupRolesTableName);

      jdbcDatabase.verifyTableExists(groupChildrenTableName, new String[] {
          "create table " + groupChildrenTableName + " (parentgroupid long,"
          + " childgroupid long)"});
       LOGGER.logp(Level.INFO, CLASS_NAME, METHOD,
           "Created/verified table: " + groupChildrenTableName);
    } catch (Exception e) {
      LOGGER.logp(Level.SEVERE, CLASS_NAME, METHOD,
          "Failed to initialize user cache", e);
      throw new RepositoryException("Failed to initialize user cache", e);
    } finally {
      if (conn != null) {
        try {
          conn.close();
        } catch (SQLException e) {
          LOGGER.logp(Level.SEVERE, CLASS_NAME, METHOD,
              "Failed to close database connection", e);
        }
      }
    }
  }

  void clearTables(Connection conn) {
    final String METHOD = "clearTables";
    try {
      String[] tables = { userTableName, groupTableName, roleTableName,
         userGroupsTableName, userRolesTableName, groupRolesTableName,
         groupChildrenTableName
      };
      Statement stmt = conn.createStatement();
      for (String table : tables) {
        stmt.executeUpdate("delete from " + table);
      }
    } catch (SQLException e) {
      LOGGER.logp(Level.WARNING, CLASS_NAME, METHOD,
          "Error clearing tables", e);
    }
  }
}
